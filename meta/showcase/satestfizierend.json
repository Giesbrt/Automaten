{
    "name": "dfa",
    "author": "Giesbrt",
    "token_lsts": [
        [
            "a"
        ],
        []
    ],
    "is_custom_token_lst": [
        true
    ],
    "abs_transition_idxs": [
        0
    ],
    "types": {
        "end": "Ellipse: ((180.0, 180.0), 180.0, 180.0), 6#000000##ffffff;Ellipse: ((180.0, 180.0), 153.0, 153.0), 2#000000##00000000;",
        "default": "Ellipse: ((180.0, 180.0), 180.0, 180.0), 6#000000##ffffff;"
    },
    "content_root_idx": 3,
    "content": [
        {
            "name": "q0",
            "type": "start",
            "position": [
                35.0,
                -160.0
            ],
            "background_color": "#ffffffff"
        },
        {
            "name": "q1",
            "type": "default",
            "position": [
                174.0,
                -151.0
            ],
            "background_color": "#ffffff"
        },
        {
            "name": "q2",
            "type": "default",
            "position": [
                601.0,
                -208.0
            ],
            "background_color": "#ffffff"
        },
        {
            "name": "q3",
            "type": "end",
            "position": [
                292.0,
                -204.0
            ],
            "background_color": "#ffffff"
        }
    ],
    "content_transitions": [
        [
            [
                0,
                1
            ],
            [
                "e",
                "w"
            ],
            [
                0
            ]
        ],
        [
            [
                1,
                2
            ],
            [
                "n",
                "s"
            ],
            [
                0
            ]
        ],
        [
            [
                2,
                3
            ],
            [
                "w",
                "e"
            ],
            [
                0
            ]
        ],
        [
            [
                3,
                0
            ],
            [
                "s",
                "n"
            ],
            [
                0
            ]
        ]
    ],
    "custom_python": "\"\"\"TBA\"\"\"\r\nfrom returns import result as _result\r\nfrom aplustools.io import ActLogger\r\n\r\n# Standard typing imports for aps\r\nimport typing as _ty\r\n\r\n# Abstract Machine related imports\r\nfrom automaton.base.state import State as BaseState\r\nfrom automaton.base.transition import Transition as BaseTransition\r\nfrom automaton.base.automaton import Automaton as BaseAutomaton\r\nfrom automaton.base.settings import Settings as BaseSettings\r\n\r\nfrom automaton.base.state import State\r\n\r\n\r\n# Docs generated with Chat-GPT\r\n\r\nclass DFASettings(BaseSettings):\r\n\r\n    def __init__(self):\r\n        super().__init__(\"dfa\", \"Deterministic Finite Automaton\", \"Giesbrt\",\r\n                         [[], ], [True, ], [0, ],\r\n                         {\"end\": \"Ellipse: ((180.0, 180.0), 180.0, 180.0), 6#000000##ffffff;Ellipse: ((180.0, 180.0), 153.0, 153.0), 2#000000##00000000;\",\r\n                          \"default\": \"Ellipse: ((180.0, 180.0), 180.0, 180.0), 6#000000##ffffff;\"})\r\n\r\n\r\nclass DFAState(BaseState):\r\n    \"\"\"\r\n    Represents a state in a Deterministic Finite Automaton (DFA).\r\n\r\n    This class extends the base `State` class, adding functionality to handle\r\n    transitions based on the DFA's deterministic nature.\r\n\r\n    Attributes:\r\n        Inherits all attributes from the `BaseState` class, including:\r\n        - `state_name` (str): The name of the state.\r\n        - `transitions` (_ty.Set[BaseTransition]): A set of transitions associated with the state.\r\n        - `activation_callback` (_ty.Callable or None): An optional callback executed upon state activation.\r\n    \"\"\"\r\n\r\n    def __init__(self, name: str) -> None:\r\n        \"\"\"\r\n        Initializes a DFA state with a given name.\r\n\r\n        Args:\r\n            name (str): The name of the DFA state.\r\n        \"\"\"\r\n        super().__init__(name)\r\n\r\n    def find_transition(self, current_input_char: str) -> _result.Result:\r\n        \"\"\"\r\n        Finds a transition based on the current input character.\r\n\r\n        This method iterates through all transitions associated with the state and selects\r\n        the one that is valid for the given input character. If multiple valid transitions\r\n        exist, it uses the deterministic nature of the DFA to resolve to one.\r\n\r\n        Args:\r\n            current_input_char (str): The current input character for the DFA.\r\n\r\n        Returns:\r\n            _result.Result:\r\n                - Success: Contains the target state of the valid transition.\r\n                - Failure: If no valid transition exists for the given input character.\r\n        \"\"\"\r\n        transition_functions: _ty.Set[BaseTransition] = self.get_transitions()\r\n\r\n        for function in transition_functions:\r\n            # Check if the transition is valid for the input character\r\n            if not isinstance(function.canTransition(current_input_char), _result.Success):\r\n                continue\r\n\r\n            # Activate the transition (optional behavior)\r\n            function.activate()\r\n\r\n            # Return the target state of the valid transition\r\n            return _result.Success(function.get_transition_target())\r\n\r\n        # If no valid transition is found, return a failure result\r\n        return _result.Failure(f\"No transition found for state {self.get_name()}!\")\r\n\r\n\r\nclass DFATransition(BaseTransition):\r\n    \"\"\"\r\n    Represents a transition between two states in a Deterministic Finite Automaton (DFA).\r\n\r\n    A transition is valid if the current input character matches the transition's\r\n    condition character. This class defines the `canTransition` method to check\r\n    if the transition can occur based on the input.\r\n\r\n    Attributes:\r\n        condition (str): The character that must match the input for the transition to occur.\r\n        start_state (BaseState): The state where the transition originates.\r\n        transition_target_state (BaseState): The state where the transition leads.\r\n    \"\"\"\r\n\r\n    def __init__(self, start_state: BaseState, transition_target_state: BaseState,\r\n                 condition: _ty.List[_ty.Any] | str) -> None:\r\n        \"\"\"\r\n        Initializes a transition with the start state, target state, and the input character condition.\r\n\r\n        Args:\r\n            start_state (BaseState): The state where the transition originates.\r\n            transition_target_state (BaseState): The state where the transition leads.\r\n            condition (str): The input character that triggers this transition.\r\n        \"\"\"\r\n        super().__init__(start_state, transition_target_state, list(condition))\r\n\r\n    def canTransition(self, current_input: _ty.Any) -> _result.Result:\r\n        \"\"\"\r\n        Checks whether the transition is valid for the given input character.\r\n\r\n        This method compares the current input character with the condition character\r\n        to determine if the transition can occur.\r\n\r\n        Args:\r\n            current_input (_ty.Any): The current input character to check.\r\n\r\n        Returns:\r\n            _result.Result:\r\n                - Success: If the transition can occur (the input matches the condition).\r\n                - Failure: If the transition cannot occur (the input does not match the condition).\r\n        \"\"\"\r\n        if self.get_condition()[0] == current_input:\r\n            return _result.Success(None)  # Transition can occur\r\n        return _result.Failure(f\"Can not transition with input {str(current_input)}!\")  # Invalid transition\r\n\r\n\r\nclass DFAAutomaton(BaseAutomaton):\r\n    \"\"\"\r\n    Represents a Deterministic Finite Automaton (DFA).\r\n\r\n    A DFA is a type of automaton used to recognize patterns in strings based on a finite set of\r\n    states, transitions, and an alphabet. The DFA begins in a start state, reads characters from\r\n    an input word, and transitions between states based on the current state and input character.\r\n    The simulation determines whether the word is accepted or rejected based on whether the\r\n    automaton terminates in an end state.\r\n\r\n    Attributes:\r\n        word (str):\r\n            The input word to be processed by the automaton.\r\n\r\n        char_index (int):\r\n            Tracks the current position in the input word.\r\n\r\n        current_char (str):\r\n            The current character being processed from the input word.\r\n\r\n        end_states (_ty.Set[DFAState]):\r\n            A set of accepting (end) states for the automaton.\r\n\r\n    Methods:\r\n        __init__():\r\n            Initializes the DFA with empty states, transitions, and input word.\r\n\r\n        set_word(new_word: str) -> None:\r\n            Sets a new input word for the automaton to process.\r\n\r\n        get_word() -> str:\r\n            Retrieves the input word for the automaton to process.\r\n\r\n        next_char() -> None:\r\n            Advances the automaton to the next character in the input word.\r\n\r\n        set_end_states(new_end_states: _ty.Set[DFAState]) -> None:\r\n            Sets the accepting (end) states for the automaton.\r\n\r\n        get_end_states() -> _ty.Set[DFAState]:\r\n            Retrieves the set of accepting (end) states.\r\n\r\n        next_state() -> None:\r\n            Processes a transition based on the current state and input character.\r\n\r\n        save(file_path: str) -> bool:\r\n            Placeholder for saving the DFA configuration to a file. (To be implemented)\r\n\r\n        load(file_path: str) -> bool:\r\n            Placeholder for loading the DFA configuration from a file. (To be implemented)\r\n\r\n        simulate() -> _result.Result:\r\n            Runs the DFA simulation on the input word and returns the result of acceptance or rejection.\r\n\r\n        simulate_one_step() -> _result.Result:\r\n            Runs one step of the DFA simulation on the input word and returns the result of acceptance or rejection.\r\n    \"\"\"\r\n\r\n    def __init__(self) -> None:\r\n        \"\"\"\r\n        Initializes a Deterministic Finite Automaton (DFA) instance.\r\n\r\n        This constructor initializes the DFA with:\r\n        - An empty input word.\r\n        - No accepting (end) states.\r\n        - A character index set to the beginning of the word.\r\n        - The current character set to an empty string.\r\n\r\n        It also ensures that the base automaton properties, such as states and transitions, are initialized.\r\n        \"\"\"\r\n        super().__init__()\r\n        self.word: list = []\r\n        self.char_index: int = 0\r\n        self.current_char: str = \"\"\r\n\r\n        self._end_states: _ty.Set[State] = set()\r\n\r\n    def set_input(self, automaton_input: _ty.Any) -> None:\r\n        \"\"\"\r\n        Sets a new input word for the DFA to process.\r\n\r\n        Args:\r\n            automaton_input (str): The string of characters to be processed by the automaton.\r\n        \"\"\"\r\n        self.word = list(automaton_input)\r\n        self.char_index = 0\r\n        self.current_char = self.word[self.char_index] if self.word else \"\"\r\n\r\n    def get_input(self) -> _ty.Any:\r\n        return self.word\r\n\r\n    def next_char(self) -> None:\r\n        \"\"\"\r\n        Advances the DFA to the next character in the input word.\r\n\r\n        If the end of the word is reached, the character index is clamped to the word's bounds.\r\n        \"\"\"\r\n        self.char_index += 1\r\n        self.current_char = self.word[max(0, min(self.char_index, len(self.word) - 1))]\r\n\r\n    def next_state(self) -> _result.Result:\r\n        \"\"\"\r\n        Transitions the DFA to the next state based on the current state and input character.\r\n\r\n        Uses the `find_transition` method of the current state to determine the appropriate transition.\r\n        If no valid transition is found or the target state is invalid, the automaton halts.\r\n        \"\"\"\r\n        transition_result: _result.Result = self.current_state.find_transition(self.current_char)\r\n\r\n        if not isinstance(transition_result, _result.Success):\r\n            return _result.Failure(\"No valid transition found!\")  # No valid transition found.\r\n\r\n        transition: DFAState = transition_result.value_or(None)\r\n        if not transition or transition not in self.states:\r\n            return _result.Failure(\"Invalid target state!\")  # Invalid target state.\r\n\r\n        self.current_state = transition\r\n        return _result.Success(None)\r\n\r\n    def simulate_one_step(self) -> _result.Result:\r\n        \"\"\"\r\n        Runs one step of the DFA simulation on the input word.\r\n\r\n        The simulation begins at the start state and processes each character in the input word,\r\n        transitioning between states based on the DFA's transition rules. If the DFA ends in an\r\n        accepting state after processing the entire word, it returns a success result. Otherwise,\r\n        it returns a failure result.\r\n\r\n        Returns:\r\n            _result.Result:\r\n                - Success: If the DFA terminates in an accepting state.\r\n                - Failure: If the DFA fails to terminate in an accepting state.\r\n\r\n        Notes:\r\n            If no start state is set or the start state is not part of the automaton's states,\r\n            an error is logged and the simulation returns a failure.\r\n        \"\"\"\r\n        if self.char_index >= len(self.word):\r\n            if self.current_state in self._end_states:\r\n                return _result.Success(\"Automaton terminated in an end state!\")\r\n            return _result.Failure(\"Automaton failed to terminate in an end state!\")\r\n\r\n        if not self.start_state:\r\n            ActLogger().error(\"Tried to start simulation of DFA-Automaton without start state!\")\r\n            return _result.Failure(\"No start state found\")\r\n\r\n        if self.start_state not in self.states:\r\n            ActLogger().error(\"Tried to start simulation of DFA-Automaton without start state in automaton states!\")\r\n            return _result.Failure(\"Start state not in automaton states\")\r\n\r\n        # loop die alle states und transitions deaktiviert (state#deactivate())\r\n        for state in self.get_states():\r\n            state.deactivate()\r\n\r\n        for transition in self.get_transitions():\r\n            transition.deactivate()\r\n\r\n        if self.current_state is None:\r\n            self.current_state = self.start_state\r\n            self.current_state.activate()\r\n\r\n        result: _result.Result = self.next_state()  # Transition to the next state.\r\n        if not isinstance(result, _result.Success):\r\n            ActLogger().error(result._inner_value or \"Failed to cache error message!\")\r\n            return result\r\n\r\n        self.next_char()  # Move to the next character in the input.\r\n        self.current_state.activate()  # Activate the current state (if such behavior is defined).\r\n\r\n    def get_current_return_value(self) -> _ty.Any:\r\n        \"\"\"\r\n        Returns the last return value of the automaton after one step of simulation\r\n\r\n        Returns:\r\n            _ty.Any: The return value\r\n        \"\"\"\r\n        return None  # None due to the lack of return values in a dfa automaton\r\n\r\n    def get_current_index(self) -> int:\r\n        \"\"\"\r\n        Returns the current index where the pointer (on the input sequence) is located\r\n\r\n        Returns:\r\n            int: current index of the pointer\r\n        \"\"\"\r\n        return self.char_index\r\n\r\n    def add_state(self, state: State, state_type: str) -> None:\r\n        self.states.add(state)\r\n        match state_type:\r\n            case \"end\":\r\n                self._end_states.add(state)\r\n\r\n            case \"default\":\r\n                pass\r\n"
}