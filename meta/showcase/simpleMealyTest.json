{
    "name": "mealy",
    "author": "Fa4953",
    "token_lsts": [
        ["a", "b"],
        ["a", "b"]
    ],
    "is_custom_token_lst": [true, false],
    "abs_transition_idxs": [0, 0],
    "types": {
        "Default": "Ellipse: ((180.0, 180.0), 180.0, 180.0), 6#000000##00000000;",
        "Start": "Ellipse: ((180.0, 180.0), 180.0, 180.0), 6#000000##00000000;Polygon: ((80.0, 160.0), (230.0, 160.0), (230.0, 130.0), (280.0, 180.0), (230.0, 230.0), (230.0, 200.0), (80.0, 200.0)), 0#ff0000##ff0000;"
    },
    "content_root_idx": 0,
    "content": [
        {
            "name": "q0",
            "type": "Start",
            "position": [-34.0, -103.0],
            "background_color": "#ffffffff"
        },
        {
            "name": "q1",
            "type": "Default",
            "position": [156.10950652619306, -101.17809869476142],
            "background_color": "#ffffff"
        },
        {
            "name": "q2",
            "type": "Default",
            "position": [352.5475326309651, -98.72262336845176],
            "background_color": "#ffffff"
        }
    ],
    "content_transitions": [
        [
            [0, 1],
            ["e", "w"],
            [0, 1]
        ],
        [
            [1, 2],
            ["e", "w"],
            [0, 1]
        ],
        [
            [2, 2],
            ["e", "e"],
            [0, 1]
        ],
        [
            [2, 2],
            ["n", "n"],
            [1, 1]
        ]
    ],
    "custom_python": "from returns import result as _result\r\nimport sys\r\nimport os\r\n# sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../base')))\r\n# Abstract Machine related imports\r\nfrom automaton.base.state import State as BaseState\r\nfrom automaton.base.transition import Transition as BaseTransition\r\nfrom automaton.base.automaton import Automaton as BaseAutomaton\r\n# Standard typing imports for advanced functionality\r\nimport collections.abc as _a\r\nimport typing as _ty\r\nimport types as _ts\r\nfrom automaton.base.settings import Settings as BaseSettings\r\n\r\n\r\n# Comments generated with Chat-GPT\r\n\r\nclass MealySettings(BaseSettings):\r\n\r\n    def __init__(self):\r\n        super().__init__(\"mealy\", \"mealy automaton\", \"Fa4953\",\r\n                         [[], []], [True, True], [0, 1],\r\n                         {'Default': \"Ellipse: ((180.0, 180.0), 180.0, 180.0), 6#000000##00000000;\",\r\n                                                    'Start': \"Ellipse: ((180.0, 180.0), 180.0, 180.0), 6#000000##00000000;Polygon: ((80.0, 160.0), (230.0, 160.0), (230.0, 130.0), (280.0, 180.0), (230.0, 230.0), (230.0, 200.0), (80.0, 200.0)), 0#ff0000##ff0000;\"})\r\n\r\n\r\nclass MealyState(BaseState):\r\n    \"\"\"\r\n    Represents a state in a Mealy Machine.\r\n\r\n    This class extends the base `State` class, providing additional functionality\r\n    to handle transitions in the context of a Mealy Machine. It supports determining\r\n    valid transitions based on the current input symbol.\r\n\r\n    Attributes:\r\n        Inherits all attributes from the `BaseState` class, including:\r\n        - `state_name` (str): The unique name of the state.\r\n        - `transitions` (_ty.Set[BaseTransition]): A set of transitions associated with this state.\r\n        - `activation_callback` (_ty.Optional[_ty.Callable]): An optional callback executed when the state is activated.\r\n    \"\"\"\r\n\r\n    def __init__(self, name: str) -> None:\r\n        \"\"\"\r\n        Initializes a state for the Mealy Machine with a given name.\r\n\r\n        Args:\r\n            name (str): The name of the state.\r\n        \"\"\"\r\n        super().__init__(name)\r\n\r\n    def find_transition(self, current_input: any) -> _result.Result:\r\n        \"\"\"\r\n        Identifies a valid transition based on the current input symbol.\r\n\r\n        This method iterates through the transitions associated with the state,\r\n        checks which transition can process the given input symbol, and resolves\r\n        deterministically to one valid transition.\r\n\r\n        Args:\r\n            current_input (any): The symbol currently being processed by the Mealy Machine.\r\n\r\n        Returns:\r\n            _result.Result:\r\n                - Success: Contains the target state of a valid transition and any associated output.\r\n                - Failure: If no valid transition exists for the given input symbol.\r\n\r\n        Behavior:\r\n            - If a transition is valid for the input symbol, it is activated (optional behavior),\r\n              and the target state along with the output is returned.\r\n            - If no valid transitions are found, a failure result is returned.\r\n        \"\"\"\r\n        transition_functions: _ty.Set[BaseTransition] = self.get_transitions()\r\n\r\n        for function in transition_functions:\r\n            # Check if the transition is valid for the current input symbol\r\n            if not isinstance(function.canTransition(current_input), _result.Success):\r\n                continue\r\n\r\n            # Activate the transition (if applicable)\r\n            function.activate()\r\n            result_output = function.canTransition(current_input)\r\n            output = result_output.unwrap()\r\n\r\n            # Return the target state and the output\r\n            return _result.Success((function.get_transition_target(), output))\r\n\r\n        # If no valid transitions exist, return a failure result\r\n        return _result.Failure(f\"No transition found for state {self.get_name()}!\")\r\n\r\n\r\nclass MealyTransition(BaseTransition):\r\n    \"\"\"\r\n    Represents a transition between two states in a Mealy Machine.\r\n\r\n    A transition is defined by a condition that specifies when the transition can occur,\r\n    as well as the output to be produced if the transition is taken.\r\n\r\n    Attributes:\r\n        condition_input (any):\r\n            The input symbol or condition required for the transition to occur.\r\n        start_state (BaseState):\r\n            The state where the transition originates.\r\n        transition_target_state (BaseState):\r\n            The state where the transition leads.\r\n        output (any):\r\n            The output associated with the transition when it is taken.\r\n    \"\"\"\r\n\r\n    def __init__(self, start_state: BaseState, transition_target_state: BaseState, condition: any) -> None:\r\n        \"\"\"\r\n        Initializes a transition with the start state, target state, and condition details.\r\n\r\n        Args:\r\n            start_state (BaseState): The state where the transition originates.\r\n            transition_target_state (BaseState): The state where the transition leads.\r\n            condition (any): The condition required for the transition to occur.\r\n            output (any): The output produced when the transition is taken.\r\n        \"\"\"\r\n        super().__init__(start_state, transition_target_state, condition)\r\n        self.condition_input: any = condition[0]\r\n        self.output: any = condition[1]\r\n\r\n    def get_condition(self):\r\n        \"\"\"\r\n        Retrieves the condition associated with the transition.\r\n\r\n        Returns:\r\n            any: The condition required for the transition to occur.\r\n        \"\"\"\r\n        return self.condition_input\r\n\r\n    def canTransition(self, current_input: _ty.Any) -> _result.Result:\r\n        \"\"\"\r\n        Determines if the transition is valid for the given input and returns the associated output.\r\n\r\n        This method checks if the transition condition matches the current input. If the transition\r\n        is valid, it returns the associated output.\r\n\r\n        Args:\r\n            current_input (_ty.Any): The current input symbol to evaluate.\r\n\r\n        Returns:\r\n            _result.Result:\r\n                - Success: If the transition is valid, returns the output associated with the transition.\r\n                - Failure: If the transition is invalid, returns an error message.\r\n        \"\"\"\r\n\r\n        if self.condition_input == current_input or self.condition_input == \"_\":\r\n            output = self.output  # Output\r\n            return _result.Success(output)  # Transition can occur\r\n\r\n        return _result.Failure(f\"Cannot transition with input {str(current_input)}!\")  # Invalid transition\r\n\r\n\r\n#from aplustools.io import ActLogger\r\nclass MealyAutomaton(BaseAutomaton):\r\n    \"\"\"\r\n    Represents a Mealy Automaton.\r\n\r\n    A Mealy automaton is a finite-state machine where the output is determined by the current state\r\n    and the current input. It consists of states, transitions, an input alphabet, and an output alphabet.\r\n\r\n    Attributes:\r\n        input (list):\r\n            The input sequence to be processed by the automaton.\r\n\r\n        input_index (int):\r\n            Tracks the current position in the input sequence.\r\n\r\n        current_input (any):\r\n            The current input element being processed.\r\n\r\n        input_alphabet (list):\r\n            The set of allowable inputs for the automaton.\r\n\r\n        output_alphabet (list):\r\n            The set of possible outputs for the automaton.\r\n\r\n        output (any):\r\n            The current output generated by the automaton.\r\n\r\n    Methods:\r\n        __init__():\r\n            Initializes the Mealy automaton with empty states, transitions, and alphabets.\r\n\r\n        set_input(input: list) -> None:\r\n            Sets a new input sequence for the automaton to process.\r\n\r\n        get_input() -> any:\r\n            Retrieves the current input sequence.\r\n\r\n        set_input_alphabet(alphabet: list) -> None:\r\n            Sets the input alphabet for the automaton.\r\n\r\n        get_input_alphabet() -> list:\r\n            Retrieves the input alphabet for the automaton.\r\n\r\n        set_output_alphabet(alphabet: list) -> None:\r\n            Sets the output alphabet for the automaton.\r\n\r\n        get_output_alphabet() -> list:\r\n            Retrieves the output alphabet for the automaton.\r\n\r\n        next_input() -> None:\r\n            Advances the automaton to the next input in the sequence.\r\n\r\n        next_state() -> _result.Result:\r\n            Transitions the automaton to the next state based on the current state and input.\r\n\r\n        simulate() -> _result.Result:\r\n            Runs the automaton simulation on the input sequence.\r\n\r\n        simulate_one_step() -> _result.Result:\r\n            Executes a single step of the automaton simulation.\r\n    \"\"\"\r\n\r\n    def __init__(self) -> None:\r\n        \"\"\"\r\n        Initializes a Mealy automaton instance.\r\n\r\n        This constructor sets up:\r\n        - An empty input sequence.\r\n        - Input and output alphabets as empty lists.\r\n        - The input index set to the beginning of the sequence.\r\n        - The output initialized to None.\r\n        \"\"\"\r\n        super().__init__()\r\n        self.input_alphabet: list = []\r\n        self.output_alphabet: list = []\r\n        self.input: list = []\r\n        self.input_index: int = 0\r\n        self.output: any = None\r\n        self.current_input = None\r\n\r\n    def set_input(self, input: list) -> None:\r\n        \"\"\"\r\n        Sets a new input sequence for the automaton to process.\r\n\r\n        Args:\r\n            input (list): The sequence of inputs to be processed by the automaton.\r\n        \"\"\"\r\n        self.input = input\r\n        self.input_index = 0\r\n        if not self.input:\r\n            self.current_input = None\r\n        else:\r\n            self.current_input = self.input[self.input_index]\r\n\r\n    def get_input(self) -> _ty.Any:\r\n        \"\"\"\r\n        Retrieves the current input sequence.\r\n\r\n        Returns:\r\n            any: The input sequence currently set for the automaton.\r\n        \"\"\"\r\n        return self.input\r\n\r\n    def get_output(self) -> _ty.Any:\r\n        return self.output\r\n\r\n    def set_input_alphabet(self, alphabet: _ty.Any) -> None:\r\n        \"\"\"\r\n        Sets the input alphabet for the automaton.\r\n\r\n        Args:\r\n            alphabet (list): The allowable set of input symbols.\r\n        \"\"\"\r\n        self.input_alphabet = alphabet\r\n\r\n    def set_output_alphabet(self, alphabet: _ty.Any) -> None:\r\n        \"\"\"\r\n        Sets the output alphabet for the automaton.\r\n\r\n        Args:\r\n            alphabet (list): The allowable set of output symbols.\r\n        \"\"\"\r\n        self.output_alphabet = alphabet\r\n\r\n    def get_input_alphabet(self) -> _ty.Any:\r\n        \"\"\"\r\n        Retrieves the input alphabet for the automaton.\r\n\r\n        Returns:\r\n            list: The set of input symbols for the automaton.\r\n        \"\"\"\r\n        return self.input_alphabet\r\n\r\n    def get_output_alphabet(self) -> _ty.Any:\r\n        \"\"\"\r\n        Retrieves the output alphabet for the automaton.\r\n\r\n        Returns:\r\n            list: The set of output symbols for the automaton.\r\n        \"\"\"\r\n        return self.output_alphabet\r\n\r\n    def next_input(self) -> None:\r\n        \"\"\"\r\n        Advances the automaton to the next input in the sequence.\r\n\r\n        Updates the current input element and ensures the input index remains within bounds.\r\n        \"\"\"\r\n        self.input_index += 1\r\n        if self.input_index < len(self.input):\r\n            self.current_input = self.input[self.input_index]\r\n        else:\r\n            self.current_input = None  # End of input sequence.\r\n\r\n    def next_state(self) -> _result.Result:\r\n        \"\"\"\r\n        Transitions the automaton to the next state based on the current state and input.\r\n\r\n        Uses the `find_transition` method of the current state to determine the appropriate transition.\r\n        If no valid transition is found or the target state is invalid, the automaton halts.\r\n\r\n        Returns:\r\n            _result.Result: The output generated during the transition or a failure message.\r\n        \"\"\"\r\n        transition_result: _result.Result = self.current_state.find_transition(self.current_input)\r\n\r\n        if not isinstance(transition_result, _result.Success):\r\n            return _result.Failure(\"No valid transition found!\")\r\n\r\n        state, output = transition_result.value_or((None, None))\r\n\r\n        transition: MealyState = state\r\n        if not transition or transition not in self.states:\r\n            return _result.Failure(\"Invalid target state!\")\r\n\r\n        self.current_state = transition\r\n        return output\r\n\r\n    def simulate(self) -> _result.Result:\r\n        \"\"\"\r\n        Runs the automaton simulation on the input sequence.\r\n\r\n        The simulation starts at the initial state and processes each input element, transitioning\r\n        between states based on the automaton's transition rules. The output is generated during\r\n        each transition.\r\n\r\n        Returns:\r\n            _result.Result:\r\n                - Success: If the simulation completes without errors.\r\n                - Failure: If an error occurs during the simulation.\r\n\r\n        Notes:\r\n            If no start state is set or the start state is not part of the automaton's states,\r\n            an error is logged, and the simulation returns a failure.\r\n        \"\"\"\r\n        if not self.start_state:\r\n            #ActLogger().error(\"Tried to start simulation of Mealy Automaton without a start state!\")\r\n            return _result.Failure(\"No start state found\")\r\n\r\n        if self.start_state not in self.states:\r\n            #ActLogger().error(\"Tried to start simulation of Mealy Automaton without start state in automaton states!\")\r\n            return _result.Failure(\"Start state not in automaton states\")\r\n\r\n        self.current_state = self.start_state\r\n        self.current_state.activate()\r\n\r\n        while self.input_index < len(self.input):\r\n            output = self.next_state()\r\n            if isinstance(output, _result.Failure):\r\n                return output\r\n            self.output = output\r\n            self.input[self.get_current_index()] = self.output\r\n            print(self.output)\r\n            self.next_input()\r\n            self.current_state.activate()\r\n\r\n        return _result.Success(\"Simulation finished successfully :)\")\r\n\r\n    def simulate_one_step(self) -> _result.Result:\r\n        \"\"\"\r\n        Executes a single step of the automaton simulation.\r\n\r\n        Transitions the automaton to the next state based on the current input and state. The output\r\n        is generated during the transition.\r\n\r\n        Returns:\r\n            _result.Result:\r\n                - Success: If the step completes without errors.\r\n                - Failure: If an error occurs during the step.\r\n\r\n        Notes:\r\n            If no start state is set or the start state is not part of the automaton's states,\r\n            an error is logged, and the simulation step returns a failure.\r\n        \"\"\"\r\n        if self.input_index >= len(self.input):\r\n            return _result.Success(\"End of input sequence reached :)\")\r\n\r\n        if not self.start_state:\r\n            #ActLogger().error(\"Tried to start simulation of Mealy Automaton without a start state!\")\r\n            return _result.Failure(\"No start state found\")\r\n\r\n        if self.start_state not in self.states:\r\n            #ActLogger().error(\"Tried to start simulation of Mealy Automaton without start state in automaton states!\")\r\n            return _result.Failure(\"Start state not in automaton states\")\r\n\r\n        for state in self.states:\r\n            state.deactivate()\r\n\r\n        for transition in self.transitions:\r\n            transition.deactivate()\r\n\r\n        if self.current_state is None:\r\n            self.current_state = self.start_state\r\n            self.current_state.activate()\r\n\r\n        output = self.next_state()\r\n        if isinstance(output, _result.Failure):\r\n            return output\r\n\r\n        self.output = output\r\n        self.input[self.get_current_index()] = self.output\r\n        self.next_input()\r\n        self.current_state.activate()\r\n\r\n    def add_state(self, state: MealyState, state_type: str) -> None:\r\n        self.states.add(state)\r\n        match state_type.lower():\r\n            case \"end\":\r\n                self.end_states.add(state)\r\n            case \"default\":\r\n                pass\r\n\r\n    def get_current_index(self) -> int:\r\n        return self.input_index\r\n\r\n    def get_current_return_value(self) -> _ty.Any:\r\n        return self.output\r\n"
}