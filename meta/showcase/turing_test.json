{
    "name": "tm",
    "author": "Fa4953",
    "token_lsts": [
        ["1", "0", "B", "X"],
        ["L", "R", "H"]
    ],
    "is_custom_token_lst": [true, false],
    "abs_transition_idxs": [0, 0, 1],
    "types": {
        "Default": "Ellipse: ((180.0, 180.0), 180.0, 180.0), 6#000000##00000000;",
        "Start": "Ellipse: ((180.0, 180.0), 180.0, 180.0), 6#000000##00000000;Polygon: ((80.0, 160.0), (230.0, 160.0), (230.0, 130.0), (280.0, 180.0), (230.0, 230.0), (230.0, 200.0), (80.0, 200.0)), 0#ff0000##ff0000;",
        "End": "Ellipse: ((180.0, 180.0), 180.0, 180.0), 6#000000##00000000;Ellipse: ((180.0, 180.0), 153.0, 153.0), 2#000000##00000000;"
    },
    "content_root_idx": 0,
    "content": [
        {
            "name": "q0",
            "type": "Default",
            "position": [46.0, -93.0],
            "background_color": "#ffffffff"
        },
        {
            "name": "q1",
            "type": "Default",
            "position": [59.0, 120.0],
            "background_color": "#ffffff"
        }
    ],
    "content_transitions": [
        [
            [0, 1],
            ["s", "n"],
            []
        ],
        [
            [1, 0],
            ["n", "s"],
            []
        ]
    ],
    "custom_python": "from returns import result as _result\r\n#from aplustools.io import ActLogger\r\nimport sys\r\nimport os\r\n\r\n\r\n# Standard typing imports for aps\r\nimport collections.abc as _a\r\nimport typing as _ty\r\nimport types as _ts\r\n#sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..')))\r\n# Abstract Machine related imports\r\nfrom automaton.base.automaton import Automaton as BaseAutomaton\r\nfrom automaton.base.state import State as BaseState\r\nfrom automaton.base.transition import Transition as BaseTransition\r\nfrom automaton.base.settings import Settings as BaseSettings\r\n# Comments generated with Chat-GPT\r\n\r\nclass TmSettings(BaseSettings):\r\n\r\n    def __init__(self):\r\n        super().__init__(\"tm\", \"touring machine\", \"Fa4953\",\r\n                         [[], ['L', 'R', 'H']], [True, False], [0, 0, 1],\r\n                         {'Default': \"Ellipse: ((180.0, 180.0), 180.0, 180.0), 6#000000##00000000;\",\r\n                          'Start': \"Ellipse: ((180.0, 180.0), 180.0, 180.0), 6#000000##00000000;Polygon: ((80.0, 160.0), (230.0, 160.0), (230.0, 130.0), (280.0, 180.0), (230.0, 230.0), (230.0, 200.0), (80.0, 200.0)), 0#ff0000##ff0000;\",\r\n                          'End': \"Ellipse: ((180.0, 180.0), 180.0, 180.0), 6#000000##00000000;Ellipse: ((180.0, 180.0), 153.0, 153.0), 2#000000##00000000;\"})\r\n\r\n\r\nclass TMState(BaseState):\r\n    \"\"\"\r\n    Represents a state in a Turing Machine (TM).\r\n\r\n    This class extends the base `State` class, providing additional functionality\r\n    to handle transitions in the context of a Turing Machine. It supports determining\r\n    valid transitions based on the current input character.\r\n\r\n    Attributes:\r\n        Inherits all attributes from the `BaseState` class, including:\r\n        - `state_name` (str): The unique name of the state.\r\n        - `transitions` (_ty.Set[BaseTransition]): A set of transitions associated with this state.\r\n        - `activation_callback` (_ty.Optional[_ty.Callable]): An optional callback executed when the state is activated.\r\n    \"\"\"\r\n\r\n    def __init__(self, name: str) -> None:\r\n        \"\"\"\r\n        Initializes a state for the Turing Machine with a given name.\r\n\r\n        Args:\r\n            name (str): The name of the state.\r\n        \"\"\"\r\n        super().__init__(name)\r\n\r\n    def find_transition(self, current_input_char: str) -> _result.Result:\r\n        \"\"\"\r\n        Identifies a valid transition based on the current input character.\r\n\r\n        This method iterates through the transitions associated with the state,\r\n        checks which transition can process the given input character, and resolves\r\n        deterministically to one valid transition.\r\n\r\n        Args:\r\n            current_input_char (str): The character currently being processed by the Turing Machine.\r\n\r\n        Returns:\r\n            _result.Result:\r\n                - Success: Contains the target state of a valid transition and any associated condition.\r\n                - Failure: If no valid transition exists for the given input character.\r\n\r\n        Behavior:\r\n            - If a transition is valid for the input character, it is activated (optional behavior),\r\n              and the target state is returned.\r\n            - If no valid transitions are found, a failure result is returned.\r\n        \"\"\"\r\n        transition_functions: _ty.Set[BaseTransition] = self.get_transitions()\r\n\r\n        for function in transition_functions:\r\n            # Check if the transition is valid for the current input character\r\n            if not isinstance(function.canTransition(current_input_char), _result.Success):\r\n                continue\r\n\r\n            # Activate the transition (if applicable)\r\n            function.activate()\r\n            result_condition = function.canTransition(current_input_char)\r\n            condition = result_condition.unwrap()\r\n\r\n            # Return the target state and the condition\r\n            return _result.Success((function.get_transition_target(), condition))\r\n\r\n        # If no valid transitions exist, return a failure result\r\n        return _result.Failure(f\"No transition found for state {self.get_name()}!\")\r\n\r\nclass TMTransition(BaseTransition):\r\n    \"\"\"\r\n    Represents a transition between two states in a Turing Machine (TM).\r\n\r\n    A transition is defined by a condition that specifies when the transition can occur,\r\n    as well as the actions to be performed (writing a character and moving the head)\r\n    if the transition is taken.\r\n\r\n    Attributes:\r\n        condition_char (str): \r\n            A string that defines the transition's condition in the format `input|write|move`.\r\n            - `input`: The character that must match the input for the transition to occur.\r\n            - `write`: The character to write on the tape.\r\n            - `move`: The head movement direction (\"L\" for left, \"R\" for right, \"H\" for halt).\r\n        start_state (BaseState): \r\n            The state where the transition originates.\r\n        transition_target_state (BaseState): \r\n            The state where the transition leads.\r\n    \"\"\"\r\n\r\n    def __init__(self, start_state: BaseState, transition_target_state: BaseState, condition_char: list) -> None:\r\n        \"\"\"\r\n        Initializes a transition with the start state, target state, and condition details.\r\n\r\n        Args:\r\n            start_state (BaseState): The state where the transition originates.\r\n            transition_target_state (BaseState): The state where the transition leads.\r\n            condition_char (str): \r\n                A string in the format `input|write|move` specifying the input condition, \r\n                character to write, and head movement direction.\r\n        \"\"\"\r\n        super().__init__(start_state, transition_target_state, condition_char)\r\n        self.condition_char: list = condition_char\r\n\r\n    def canTransition(self, current_input: _ty.Any) -> _result.Result:\r\n        \"\"\"\r\n        Determines if the transition is valid for the given input and returns the associated actions.\r\n\r\n        This method splits the `condition_char` into its components (`input|write|move`) and checks\r\n        if the `input` part matches the current input. If the transition is valid, it returns the \r\n        character to write and the head movement direction.\r\n\r\n        Args:\r\n            current_input (_ty.Any): The current input character to evaluate.\r\n\r\n        Returns:\r\n            _result.Result:\r\n                - Success: If the transition is valid, returns a tuple `(to_write, head_move)` where:\r\n                    - `to_write` (str): The character to write on the tape.\r\n                    - `head_move` (str): The direction to move the head (\"L\", \"R\", or \"H\").\r\n                - Failure: If the transition is invalid, returns an error message.\r\n        \"\"\"\r\n\r\n        condition_parts = self.condition_char\r\n        if condition_parts[0] == current_input or condition_parts[0] == \"_\":\r\n            to_write = condition_parts[1]  # Character to write\r\n            head_move = condition_parts[2]  # Direction to move the head\r\n            return _result.Success((to_write, head_move))  # Transition can occur\r\n        \r\n        return _result.Failure(f\"Cannot transition with input {str(current_input)}!\")  # Invalid transition\r\n\r\n\r\nclass TMAutomaton(BaseAutomaton):\r\n    \"\"\"\r\n    Represents a Turing Machine Automaton (TMA).\r\n\r\n    A Turing Machine is a theoretical computational model capable of simulating any algorithm.\r\n    It processes an input word on an infinite tape (or bounded tape for Linear Bounded Automata),\r\n    using a finite set of states, transitions, and symbols. The machine can move its head left\r\n    or right, modify tape symbols, and decide whether to halt in an accepting state.\r\n\r\n    Attributes:\r\n        memoryTape (dict):\r\n            The tape used by the Turing Machine to process input.\r\n\r\n        head (int):\r\n            The current position of the machine's read/write head on the tape.\r\n\r\n        current_char (str):\r\n            The current symbol being processed on the tape.\r\n\r\n        LBAutomaton (bool):\r\n            Flag indicating whether the machine operates as a Linear Bounded Automaton.\r\n\r\n        end_states (_ty.Set[TMState]):\r\n            A set of accepting (end) states for the Turing Machine.\r\n\r\n    Methods:\r\n        __init__():\r\n            Initializes the Turing Machine with an empty tape, no end states, and a default mode.\r\n\r\n        set_mode(mode: str):\r\n            Sets the operational mode of the automaton (e.g., LBAutomaton).\r\n\r\n        set_input(new_word: str) -> None:\r\n            Loads a new input word onto the tape and resets the head position.\r\n\r\n        get_input() -> str:\r\n            Retrieves the input word from the tape.\r\n\r\n        right() -> None:\r\n            Moves the machine's head to the right and updates the current character.\r\n\r\n        left() -> None:\r\n            Moves the machine's head to the left and updates the current character.\r\n\r\n        write() -> None:\r\n            Writes the current character to the tape at the head's position.\r\n\r\n        set_end_states(new_end_states: _ty.Set[TMState]) -> None:\r\n            Sets the accepting (end) states for the Turing Machine.\r\n\r\n        get_end_states() -> _ty.Set[TMState]:\r\n            Retrieves the set of accepting (end) states.\r\n\r\n        next_state() -> None:\r\n            Processes a transition based on the current state and input character.\r\n\r\n        save(file_path: str) -> bool:\r\n            Placeholder for saving the Turing Machine configuration to a file. (To be implemented)\r\n\r\n        load(file_path: str) -> bool:\r\n            Placeholder for loading the Turing Machine configuration from a file. (To be implemented)\r\n\r\n        simulate() -> _result.Result:\r\n            Runs the Turing Machine simulation on the input tape and returns the result of acceptance or rejection.\r\n\r\n        simulate_one_step() -> _result.Result:\r\n            Executes one step of the Turing Machine simulation and returns the result of acceptance or rejection.\r\n    \"\"\"\r\n\r\n    def __init__(self) -> None:\r\n        \"\"\"\r\n        Initializes a Turing Machine Automaton (TMA) instance.\r\n\r\n        This constructor initializes the machine with:\r\n        - An empty memory tape.\r\n        - No accepting (end) states.\r\n        - The head positioned at the start of the tape.\r\n        - A default operational mode (non-linear bounded).\r\n\r\n        It also ensures that the base automaton properties, such as states and transitions, are initialized.\r\n        \"\"\"\r\n        super().__init__()\r\n        self.memoryTape: str = {}\r\n        self.head: int = 0\r\n        self.current_char: str = \"\"\r\n        self.LBAutomaton: bool = False\r\n        self.output_alphabet = []\r\n        self.input_alphabet = []\r\n        self.end_states: _ty.Set[TMState] = set()\r\n\r\n    def set_mode(self, mode):\r\n        \"\"\"\r\n        Sets the operational mode of the Turing Machine.\r\n\r\n        Args:\r\n            mode (str): The mode of the automaton. \"LBAutomaton\" enables linear bounded constraints.\r\n        \"\"\"\r\n        if mode == \"LBAutomaton\":\r\n            self.LBAutomaton = True\r\n        else:\r\n            self.LBAutomaton = False\r\n\r\n    def set_input(self, new_word: str) -> None:\r\n        \"\"\"\r\n        Loads a new input word onto the tape and resets the head position.\r\n\r\n        Args:\r\n            new_word (str): The string of characters to be loaded onto the tape.\r\n        \"\"\"\r\n        for key, char in enumerate(new_word):\r\n            self.memoryTape[key] = char\r\n        self.head = 0\r\n        self.current_char = self.memoryTape[self.head]\r\n\r\n    def get_current_state(self):\r\n        return super().get_current_state()\r\n\r\n    def get_input(self) -> str:\r\n        \"\"\"\r\n        Retrieves the input word from the memory tape.\r\n\r\n        Returns:\r\n            str: The reconstructed word from the tape.\r\n        \"\"\"\r\n        return \"\".join(self.memoryTape.get(i, \"B\") for i in range(min(self.memoryTape.keys()), max(self.memoryTape.keys()) + 1))\r\n    def set_input_alphabet(self, alphabet: _ty.Any) -> None:\r\n        \"\"\"\r\n        Abstract method to set the input alphabet for the automaton.\r\n\r\n        Args:\r\n            alphabet (_ty.Any): The input alphabet to be set for the automaton.\r\n        \"\"\"\r\n        self.input_alphabet = alphabet\r\n\r\n    def set_output_alphabet(self, alphabet: _ty.Any) -> None:\r\n        \"\"\"\r\n        Abstract method to set the output alphabet for the automaton.\r\n\r\n        Args:\r\n            alphabet (_ty.Any): The output alphabet to be set for the automaton.\r\n        \"\"\"\r\n        self.output_alphabet = alphabet\r\n\r\n    def get_input_alphabet(self) -> _ty.Any:\r\n        \"\"\"\r\n        Abstract method to get the input alphabet for the automaton.\r\n\r\n        Returns:\r\n            _ty.Any: The input alphabet for the automaton.\r\n        \"\"\"\r\n        return self.input_alphabet\r\n\r\n    def get_output_alphabet(self) -> _ty.Any:\r\n        \"\"\"\r\n        Abstract method to get the output alphabet for the automaton.\r\n\r\n        Returns:\r\n            _ty.Any: The output alphabet for the automaton.\r\n        \"\"\"\r\n        return self.output_alphabet\r\n\r\n    def right(self) -> None:\r\n        \"\"\"\r\n        Moves the machine's head to the right and updates the current character.\r\n\r\n        If the tape at the new position is empty, a blank symbol is added unless operating\r\n        as a Linear Bounded Automaton.\r\n\r\n        Returns:\r\n            _result.Failure: If the head attempts to move beyond the bounds in LBA mode.\r\n        \"\"\"\r\n        self.head += 1\r\n        if self.head in self.memoryTape:\r\n            self.current_char = self.memoryTape[self.head]\r\n        elif not self.LBAutomaton:\r\n            self.memoryTape[self.head] = \"B\"\r\n            self.current_char = self.memoryTape[self.head]\r\n            print(self.memoryTape)\r\n        else:\r\n            return _result.Failure(\"You can't go further, your automaton is linear bounded!\")\r\n\r\n    def left(self) -> None:\r\n        \"\"\"\r\n        Moves the machine's head to the left and updates the current character.\r\n\r\n        If the tape at the new position is empty, a blank symbol is added unless operating\r\n        as a Linear Bounded Automaton.\r\n\r\n        Returns:\r\n            _result.Failure: If the head attempts to move beyond the bounds in LBA mode.\r\n        \"\"\"\r\n        self.head -= 1\r\n        if self.head in self.memoryTape:\r\n            self.current_char = self.memoryTape[self.head]\r\n        elif not self.LBAutomaton:\r\n            self.memoryTape[self.head] = \"B\"\r\n            self.current_char = self.memoryTape[self.head]\r\n        else:\r\n            return _result.Failure(\"You can't go further, your automaton is linear bounded!\")\r\n\r\n    def write(self) -> None:\r\n        \"\"\"\r\n        Writes the current character to the tape at the head's position.\r\n        \"\"\"\r\n        if self.current_char != \"B\":\r\n            self.memoryTape[self.head] = self.current_char\r\n        else:\r\n            del self.memoryTape[self.head]\r\n\r\n    def set_end_states(self, new_end_states: _ty.Set[TMState]) -> None:\r\n        \"\"\"\r\n        Sets the accepting (end) states for the Turing Machine.\r\n\r\n        If any of the new end states are not already part of the automaton's states, they are added.\r\n\r\n        Args:\r\n            new_end_states (_ty.Set[TMState]): A set of states to mark as accepting states.\r\n        \"\"\"\r\n        for state in new_end_states:\r\n            if state not in self.get_states():\r\n                self.states.add(state)\r\n\r\n        self.end_states = new_end_states\r\n\r\n    def get_end_states(self) -> _ty.Set[TMState]:\r\n        \"\"\"\r\n        Retrieves the set of accepting (end) states for the Turing Machine.\r\n\r\n        Returns:\r\n            _ty.Set[TMState]: A set containing all the machine's accepting states.\r\n        \"\"\"\r\n        return self.end_states\r\n\r\n    def next_state(self) -> None:\r\n        \"\"\"\r\n        Processes a transition based on the current state and input character.\r\n\r\n        Uses the `find_transition` method of the current state to determine the appropriate transition.\r\n        If no valid transition is found or the target state is invalid, the machine halts.\r\n\r\n        Returns:\r\n            None: If the machine halts due to an invalid state or transition.\r\n        \"\"\"\r\n        transition_result: _result.Result = self.current_state.find_transition(self.current_char)\r\n        if not isinstance(transition_result, _result.Success):\r\n            return _result.Failure(\"There's no possible transition\")\r\n        \r\n        target_state, condition = transition_result.unwrap()\r\n\r\n        transition: TMState = target_state\r\n        if not transition or transition not in self.states:\r\n            return  _result.Failure(\"Invalid target state!\") \r\n\r\n        self.current_state = transition\r\n        print(self.current_state)\r\n        return condition\r\n\r\n    def next_location(self, callback=None):\r\n        \"\"\"\r\n        Executes a callback function to move the head or process a transition.\r\n\r\n        Args:\r\n            callback (callable, optional): A function to execute for the next operation.\r\n\r\n        Notes:\r\n            If no callback is set, the function attempts to use the \"choose_function\" attribute.\r\n        \"\"\"\r\n        if not hasattr(self, \"choose_function\"):\r\n            print(\"Attribute 'choose_function' has not been set.\")\r\n            if callback:\r\n                self.choose_function = callback\r\n            else:\r\n                print(\"No callback provided.\")\r\n                return\r\n        else:\r\n            self.choose_function()\r\n            delattr(self, \"choose_function\")\r\n\r\n    def simulate(self) -> _result.Result:\r\n        \"\"\"\r\n        Runs the Turing Machine simulation on the input tape.\r\n\r\n        The simulation begins at the start state and processes tape symbols based on transition rules.\r\n        It writes to the tape, moves the head, and halts when a halting condition is met. The result\r\n        depends on whether the machine ends in an accepting state.\r\n\r\n        Returns:\r\n            _result.Result:\r\n                - Success: If the machine halts in an accepting state.\r\n                - Failure: If the machine halts in a non-accepting state or encounters an error.\r\n\r\n        Notes:\r\n            If no start state is set or the start state is not part of the automaton's states,\r\n            an error is logged and the simulation returns a failure.\r\n        \"\"\"\r\n        if not self.start_state:\r\n            #ActLogger().error(\"Tried to start simulation of TM-Automaton without start state!\")\r\n            return _result.Failure(\"No start state found\")\r\n\r\n        if self.start_state not in self.states:\r\n            #ActLogger().error(\"Tried to start simulation of TM-Automaton without start state in automaton states!\")\r\n            return _result.Failure(\"Start state not in automaton states\")\r\n\r\n        self.current_state = self.start_state\r\n        self.current_state.activate()\r\n\r\n        while True:\r\n            condition = self.next_state()  # Transition to the next state.\r\n            if isinstance(condition, _result.Failure):\r\n                return condition\r\n            if isinstance(condition, tuple) and len(condition) == 2:\r\n                self.current_char = condition[0] \r\n            else:\r\n                return _result.Failure(\"There is no condition!\")\r\n            if self.current_char != \"_\":\r\n                self.write()\r\n            if condition[1] == \"L\":\r\n                self.left()\r\n            elif condition[1] == \"R\":\r\n                self.right()\r\n            elif condition[1] == \"H\":\r\n                break\r\n\r\n            self.current_char = self.memoryTape[self.head]\r\n            self.current_state.activate()  # Activate the current state (if such behavior is defined).\r\n\r\n        if self.current_state in self.end_states:\r\n            return _result.Success(\"Automaton terminated in an end state!\")\r\n        return _result.Failure(\"Automaton failed to terminate in an end state!\")\r\n\r\n    def simulate_one_step(self) -> _result.Result:\r\n        \"\"\"\r\n        Executes one step of the Turing Machine simulation.\r\n\r\n        Processes the current tape symbol, transitions to the next state, updates the tape if needed,\r\n        and moves the head based on the transition rule. The machine halts if a halting condition\r\n        is reached during the step.\r\n\r\n        Returns:\r\n            _result.Result:\r\n                - Success: If the machine halts in an accepting state during the step.\r\n                - Failure: If the machine halts in a non-accepting state or encounters an error.\r\n\r\n        Notes:\r\n            If no start state is set or the start state is not part of the automaton's states,\r\n            an error is logged and the simulation returns a failure.\r\n        \"\"\"\r\n        for state in self.states:\r\n            state.deactivate()\r\n        for transition in self.transitions:\r\n            transition.deactivate()\r\n        if not self.start_state:\r\n            #ActLogger().error(\"Tried to start simulation of DFA-Automaton without start state!\")\r\n            return _result.Failure(\"No start state found\")\r\n\r\n        if self.start_state not in self.states:\r\n            #ActLogger().error(\"Tried to start simulation of DFA-Automaton without start state in automaton states!\")\r\n            return _result.Failure(\"Start state not in automaton states\")\r\n\r\n        if self.current_state is None:\r\n            self.current_state = self.start_state\r\n            self.current_state.activate()\r\n\r\n\r\n        condition = self.next_state()  # Transition to the next state.\r\n        if isinstance(condition, _result.Failure):\r\n            return condition\r\n        if isinstance(condition, tuple) and len(condition) == 2:\r\n            self.current_char = condition[0] \r\n            self.write()\r\n        else: \r\n            return _result.Failure(\"There is no condition.\")\r\n        if condition[1] == \"L\":\r\n            self.left()\r\n        if condition[1] == \"R\":\r\n            self.right()\r\n        if condition[1] == \"H\":\r\n            if self.current_state in self.end_states:\r\n                return _result.Success(\"Automaton terminated in an end state!\")\r\n            return _result.Failure(\"Automaton failed to terminate in an end state!\")\r\n\r\n    def add_state(self, state: BaseState, state_type: str) -> None:\r\n        self.states.add(state)\r\n        match state_type:\r\n            case \"end\":\r\n                self.end_states.add(state)\r\n            case \"default\":\r\n                pass\r\n                \r\n\r\n    def get_current_index(self) -> int:\r\n        return self.head\r\n\r\n    def get_current_return_value(self) -> _ty.Any:\r\n        return self.memoryTape\r\n\r\n\r\n\r\n"
}