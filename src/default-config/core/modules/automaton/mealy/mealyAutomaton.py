from returns import result as _result
#from aplustools.io import ActLogger



# Standard typing imports for aps
import collections.abc as _a
import typing as _ty
import types as _ts
# Abstract Machine related imports
from mealyState import MealyState
from automaton import Automaton as BaseAutomaton

# Comments generated with Chat-GPT

class MealyAutomaton(BaseAutomaton):
    """
    Represents a Mealy Automaton.

    A Mealy automaton is a finite-state machine where the output is determined by the current state
    and the current input. It consists of states, transitions, an input alphabet, and an output alphabet.

    Attributes:
        input (list):
            The input sequence to be processed by the automaton.

        input_index (int):
            Tracks the current position in the input sequence.

        current_input (any):
            The current input element being processed.

        input_alphabet (list):
            The set of allowable inputs for the automaton.

        output_alphabet (list):
            The set of possible outputs for the automaton.

        output (any):
            The current output generated by the automaton.

    Methods:
        __init__():
            Initializes the Mealy automaton with empty states, transitions, and alphabets.

        set_input(input: list) -> None:
            Sets a new input sequence for the automaton to process.

        get_input() -> any:
            Retrieves the current input sequence.

        set_input_alphabet(alphabet: list) -> None:
            Sets the input alphabet for the automaton.

        get_input_alphabet() -> list:
            Retrieves the input alphabet for the automaton.

        set_output_alphabet(alphabet: list) -> None:
            Sets the output alphabet for the automaton.

        get_output_alphabet() -> list:
            Retrieves the output alphabet for the automaton.

        next_input() -> None:
            Advances the automaton to the next input in the sequence.

        next_state() -> _result.Result:
            Transitions the automaton to the next state based on the current state and input.

        simulate() -> _result.Result:
            Runs the automaton simulation on the input sequence.

        simulate_one_step() -> _result.Result:
            Executes a single step of the automaton simulation.
    """

    def __init__(self) -> None:
        """
        Initializes a Mealy automaton instance.

        This constructor sets up:
        - An empty input sequence.
        - Input and output alphabets as empty lists.
        - The input index set to the beginning of the sequence.
        - The output initialized to None.
        """
        super().__init__()
        self.input_alphabet: list = []
        self.output_alphabet: list = []
        self.input: list = []
        self.input_index: int = 0
        self.output: any = None
        self.current_input = None

    def set_input(self, input: list) -> None:
        """
        Sets a new input sequence for the automaton to process.

        Args:
            input (list): The sequence of inputs to be processed by the automaton.
        """
        self.input = input
        self.input_index = 0
        if not self.input:
            self.current_input = None
        else:
            self.current_input = self.input[self.input_index]

    def get_input(self) -> _ty.Any:
        """
        Retrieves the current input sequence.

        Returns:
            any: The input sequence currently set for the automaton.
        """
        return self.input
    
    def get_output(self) -> _ty.Any:
        return self.output

    def set_input_alphabet(self, alphabet: _ty.Any) -> None:
        """
        Sets the input alphabet for the automaton.

        Args:
            alphabet (list): The allowable set of input symbols.
        """
        self.input_alphabet = alphabet

    def set_output_alphabet(self, alphabet: _ty.Any) -> None:
        """
        Sets the output alphabet for the automaton.

        Args:
            alphabet (list): The allowable set of output symbols.
        """
        self.output_alphabet = alphabet

    def get_input_alphabet(self) -> _ty.Any:
        """
        Retrieves the input alphabet for the automaton.

        Returns:
            list: The set of input symbols for the automaton.
        """
        return self.input_alphabet

    def get_output_alphabet(self) -> _ty.Any:
        """
        Retrieves the output alphabet for the automaton.

        Returns:
            list: The set of output symbols for the automaton.
        """
        return self.output_alphabet

    def next_input(self) -> None:
        """
        Advances the automaton to the next input in the sequence.

        Updates the current input element and ensures the input index remains within bounds.
        """
        self.input_index += 1
        if self.input_index < len(self.input):
            self.current_input = self.input[self.input_index]
        else:
            self.current_input = None  # End of input sequence.

    def next_state(self) -> _result.Result:
        """
        Transitions the automaton to the next state based on the current state and input.

        Uses the `find_transition` method of the current state to determine the appropriate transition.
        If no valid transition is found or the target state is invalid, the automaton halts.

        Returns:
            _result.Result: The output generated during the transition or a failure message.
        """
        transition_result: _result.Result = self.current_state.find_transition(self.current_input)

        if not isinstance(transition_result, _result.Success):
            return _result.Failure("No valid transition found!")

        state, output = transition_result.value_or((None, None))

        transition: MealyState = state
        if not transition or transition not in self.states:
            return _result.Failure("Invalid target state!")

        self.current_state = transition
        return output

    def simulate(self) -> _result.Result:
        """
        Runs the automaton simulation on the input sequence.

        The simulation starts at the initial state and processes each input element, transitioning
        between states based on the automaton's transition rules. The output is generated during
        each transition.

        Returns:
            _result.Result:
                - Success: If the simulation completes without errors.
                - Failure: If an error occurs during the simulation.

        Notes:
            If no start state is set or the start state is not part of the automaton's states,
            an error is logged, and the simulation returns a failure.
        """
        if not self.start_state:
            #ActLogger().error("Tried to start simulation of Mealy Automaton without a start state!")
            return _result.Failure("No start state found")

        if self.start_state not in self.states:
            #ActLogger().error("Tried to start simulation of Mealy Automaton without start state in automaton states!")
            return _result.Failure("Start state not in automaton states")

        self.current_state = self.start_state
        self.current_state.activate()

        while self.input_index < len(self.input):
            output = self.next_state()
            if isinstance(output, _result.Failure):
                return output
            self.output = output
            print(self.output)
            self.next_input()
            self.current_state.activate()

        return _result.Success("Simulation finished successfully :)")

    def simulate_one_step(self) -> _result.Result:
        """
        Executes a single step of the automaton simulation.

        Transitions the automaton to the next state based on the current input and state. The output
        is generated during the transition.

        Returns:
            _result.Result:
                - Success: If the step completes without errors.
                - Failure: If an error occurs during the step.

        Notes:
            If no start state is set or the start state is not part of the automaton's states,
            an error is logged, and the simulation step returns a failure.
        """
        if self.input_index >= len(self.input):
            return _result.Success("End of input sequence reached :)")

        if not self.start_state:
            #ActLogger().error("Tried to start simulation of Mealy Automaton without a start state!")
            return _result.Failure("No start state found")

        if self.start_state not in self.states:
            #ActLogger().error("Tried to start simulation of Mealy Automaton without start state in automaton states!")
            return _result.Failure("Start state not in automaton states")

        if self.current_state is None:
            self.current_state = self.start_state
            self.current_state.activate()

        output = self.next_state()
        if isinstance(output, _result.Failure):
            return output
        self.output = output
        print(self.output)
        self.next_input()
        self.current_state.activate()
        return _result.Success("No error")